/**********************************************************
 * <z64.me> zzrtl script for extracting assets from OoT   * 
 * audiobank(), audioseq(), message(), restrictionflag()  *
 * entrancecutscene(), and mapselect() by Jared Johnson   *
 **********************************************************/
/*USE THE CONFIG.TSV FILE*/
/* global variables */
char *g_tsv;
int TBL_OBJECT;int TBL_OBJECT_ENTRIES;int TBL_ACTOR;int TBL_ACTOR_ENTRIES;int TBL_PARTICLE;int TBL_PARTICLE_ENTRIES;int TBL_SCENE;int TBL_SCENE_ENTRIES;
int TBL_ROUTE;int TBL_ROUTE_ENTRIES;int TBL_MAP_SELECT;int TBL_MAP_SELECT_ENTRIES;int TBL_AUDIOSAMPLE;int TBL_AUDIOTABLE_FILE;int TBL_AUDIOTABLE_FILE_SIZE;
int TBL_AUDIOBANK;int TBL_AUDIOBANK_FILE;int TBL_SEQUENCEINSTRUMENTSET;int TBL_SEQUENCE_FILE;int TBL_AUDIOSEQ;int TBL_ENTRANCECUTSCENE;
int TBL_ENTRANCECUTSCENE_ENTRIES;int TBL_MESSAGE; int TBL_MESSAGE_ENTRIES;int TBL_MESSAGE_DATA;int TBL_RESTRICTIONFLAG;int TBL_RESTRICTIONFLAG_ENTRIES;
int TBL_DMA;int TBL_DMA_ENTRIES;int TBL_OVL_GAMESTATE;int TBL_OVL_PLAYER;int TBL_OVL_MAPMARK;int TITLECARD_W;int TITLECARD_H;int VRAM_CODE;int VROM_CODE;
int VROM_PLAYER; int DMA_ITEM_FIELD;int DMA_ITEM_LOCALIZED;int DMA_CODE;int DMA_OVL_TITLE;int DMA_OVL_SELECT;int DMA_OVL_OPENING;int DMA_OVL_FILE_CHOOSE;
int DMA_OVL_KALEIDO_SCOPE;int DMA_OVL_PLAYER_ACTOR;int DMA_OVL_MAP_MARK_DATA;int DMA_ACTOR_FIRST;int DMA_ACTOR_LAST;int DMA_OBJECT_FIRST;
int DMA_OBJECT_LAST;int DMA_G_PN_FIRST;int DMA_G_PN_LAST;int DMA_SKYBOX_FIRST;int DMA_SKYBOX_LAST;int DMA_PRERENDER_FIRST;int DMA_PRERENDER_LAST;
int DMA_SCENE_FIRST;int DMA_SCENE_LAST;int DMA_UNUSED_FIRST;int DMA_UNUSED_LAST;int DMA_SOFTSPRITE;int DMA_BLANK_FIRST;int DMA_BLANK_LAST;int ACTID_LINK;
int OFS_OVL_PLAYER_ACTOR_INIT_HI;int OFS_OVL_PLAYER_ACTOR_INIT_LO;int OFS_OVL_PLAYER_ACTOR_DEST_HI;int OFS_OVL_PLAYER_ACTOR_DEST_LO;
int OFS_OVL_PLAYER_ACTOR_MAIN_HI;int OFS_OVL_PLAYER_ACTOR_MAIN_LO;int OFS_OVL_PLAYER_ACTOR_DRAW_HI;int OFS_OVL_PLAYER_ACTOR_DRAW_LO;
int OFS_OVL_KALEIDO_SCOPE_INIT_HI;int OFS_OVL_KALEIDO_SCOPE_INIT_LO;int OFS_OVL_KALEIDO_SCOPE_DRAW_HI;int OFS_OVL_KALEIDO_SCOPE_DRAW_LO;

	 /*OoT debug */
void
debugvariables() 
{
	TBL_OBJECT              		 = 0x00B9E6C8  // object table
	; TBL_OBJECT_ENTRIES 		     = 402         // object count
	; TBL_ACTOR        		         = 0x00B8D440  // actor overlay table
	; TBL_ACTOR_ENTRIES    		     = 471         // actor overlay count
	; TBL_PARTICLE          		 = 0x00B8CB50  // particle overlay table
	; TBL_PARTICLE_ENTRIES 		     = 37          // particle overlay count
	; TBL_SCENE            		     = 0x00BA0BB0  // scene table
	; TBL_SCENE_ENTRIES    		     = 110         // scene count
	; TBL_ROUTE             		 = 0x00B9F360  // route table
	; TBL_ROUTE_ENTRIES     		 = 1556        // route count
	; TBL_MAP_SELECT				 = 0x00001430  // map select table relative to ovl_select file
	; TBL_MAP_SELECT_ENTRIES		 = 125		   // number of map select entries	
	; TBL_AUDIOSAMPLE				 = 0x00BCCDA0  //audiosample table
	; TBL_AUDIOTABLE_FILE			 = 0x00094870	
	; TBL_AUDIOTABLE_FILE_SIZE       = 0x00451390
	; TBL_AUDIOBANK 				 = 0x00BCC270  //audiobanktable
	; TBL_AUDIOBANK_FILE 			 = 0x00019030  //audiobank file
	; TBL_SEQUENCEINSTRUMENTSET		 = 0x00BCC4E0  // instrument set table
	; TBL_SEQUENCE_FILE 		     = 0x00044DF0  // sequence file offset
	; TBL_AUDIOSEQ				     = 0x00BCC6A0  // sequence pointer table
	; TBL_ENTRANCECUTSCENE 		     = 0x00B95394  // entrancecutscene table
	; TBL_ENTRANCECUTSCENE_ENTRIES   = 34          // entrancecutscene count	
	; TBL_MESSAGE 					 = 0x00BC24C0  // offset for message table
	; TBL_MESSAGE_ENTRIES  		     = 2116        // entrancecutscene count
	; TBL_MESSAGE_DATA			     = 0x008C6000  //offset for english text
	; TBL_RESTRICTIONFLAG   		 = 0x00B9CA10  //offset for restricitonflag table
	; TBL_RESTRICTIONFLAG_ENTRIES    = 73	       //restrictionflag count
	; TBL_DMA               		 = 0x00012F70  // dma table
	; TBL_DMA_ENTRIES       		 = 1548        // dma entries
	; TBL_OVL_GAMESTATE     		 = 0x00B969D0  // ovl_title
	; TBL_OVL_PLAYER        		 = 0x00BA4340  // ovl_kaleido_scope
	; TBL_OVL_MAPMARK      		     = 0x00B97298  // ovl_map_mark_data
	
	; TITLECARD_W          		     = 144         // title card dimensions
	; TITLECARD_H          		     = 24          // use 72 to include de; fr
	; VRAM_CODE              		 = 0x8001CE60  // vram start of code
	; VROM_CODE            		     = 0x00A94000  // vrom start of code
	; VROM_PLAYER          		     = 0x00C010B0  // vrom start of player_actor
	
	; DMA_ITEM_FIELD         		 = 9           // icon_item_field_static
	; DMA_ITEM_LOCALIZED    		 = 14          // last icon_item_x_static
	; DMA_CODE             		     = 28
	; DMA_OVL_TITLE					 = 29
	; DMA_OVL_SELECT				 = 30
	; DMA_OVL_OPENING				 = 31
	; DMA_OVL_FILE_CHOOSE			 = 32
	; DMA_OVL_KALEIDO_SCOPE			 = 33
	; DMA_OVL_PLAYER_ACTOR			 = 34
	; DMA_OVL_MAP_MARK_DATA			 = 35
	
	; DMA_ACTOR_FIRST      		    = 36          // En_Test
	; DMA_ACTOR_LAST        	    = 497         // Shot_Sun
	; DMA_OBJECT_FIRST      		= 498         // gameplay_keep
	; DMA_OBJECT_LAST       		= 879         // object_zl4
	; DMA_G_PN_FIRST       		    = 880         // g_pn_01
	; DMA_G_PN_LAST         		= 936         // g_pn_57
	; DMA_SKYBOX_FIRST      		= 941         // vr_fine0_static
	; DMA_SKYBOX_LAST       		= 960         // vr_holy1_pal_static
	; DMA_PRERENDER_FIRST   		= 961         // vr_MDVR_static
	; DMA_PRERENDER_LAST   		    = 1004        // vr_FCVR_pal_static
	; DMA_SCENE_FIRST       		= 1007        // syotes_scene
	; DMA_SCENE_LAST       		    = 1517        // test01_room_0
	; DMA_UNUSED_FIRST      		= 1518        // bump_texture_static
	; DMA_UNUSED_LAST      		    = 1530        // anime_texture_6_static
	; DMA_SOFTSPRITE        		= 1531        // softsprite_matrix_static
	; DMA_BLANK_FIRST       		= 1532        // first blank dma entry
	; DMA_BLANK_LAST        		= 1547        // last blank dma entry
	
	; ACTID_LINK         		    = 0           // link's actor id
	
	// hard-coded function pointers for ovl_player_actor
	; OFS_OVL_PLAYER_ACTOR_INIT_HI  = 0x00B288F8  // init
	; OFS_OVL_PLAYER_ACTOR_INIT_LO  = 0x00B28900
	; OFS_OVL_PLAYER_ACTOR_DEST_HI  = 0x00B28908  // dest
	; OFS_OVL_PLAYER_ACTOR_DEST_LO  = 0x00B28914
	; OFS_OVL_PLAYER_ACTOR_MAIN_HI  = 0x00B2891C  // main (update)
	; OFS_OVL_PLAYER_ACTOR_MAIN_LO  = 0x00B28928
	; OFS_OVL_PLAYER_ACTOR_DRAW_HI  = 0x00B28930  // draw
	; OFS_OVL_PLAYER_ACTOR_DRAW_LO  = 0x00B2893C
	
	// hard-coded function pointers for ovl_kaleido_scope
	; OFS_OVL_KALEIDO_SCOPE_INIT_HI = 0x00B33208  // init
	; OFS_OVL_KALEIDO_SCOPE_INIT_LO = 0x00B3320C
	; OFS_OVL_KALEIDO_SCOPE_DRAW_HI = 0x00B33218  // draw
	; OFS_OVL_KALEIDO_SCOPE_DRAW_LO = 0x00B33220
	;
}

void
ocarinaoftimevariables()
{
	TBL_OBJECT               = 0x00B6EF58  // object table
	; TBL_OBJECT_ENTRIES     = 402         // object count
	; TBL_ACTOR              = 0x00B5E490  // actor overlay table
	; TBL_ACTOR_ENTRIES      = 471         // actor overlay count
	; TBL_PARTICLE           = 0x00B5DBA0  // particle overlay table
	; TBL_PARTICLE_ENTRIES   = 37          // particle overlay count
	; TBL_SCENE              = 0x00B71440  // scene table
	; TBL_SCENE_ENTRIES      = 101         // scene count
	; TBL_ROUTE              = 0x00B6FBF0  // route table
	; TBL_ROUTE_ENTRIES      = 1556        // route count
	; TBL_MAP_SELECT				 = 0x000013D0  // map select table relative to ovl_select file
	; TBL_MAP_SELECT_ENTRIES		 = 115		   // number of map select entries	
	; TBL_AUDIOSAMPLE				 = 0x00B8A1D0  //audiosample table
	; TBL_AUDIOBANK 				 = 0x00B896A0  //audiobanktable
	; TBL_AUDIOBANK_FILE 			 = 0x0000D390  //audiobank file
	; TBL_SEQUENCEINSTRUMENTSET		 = 0x00B89910  // instrument set table
	; TBL_SEQUENCE_FILE 		     = 0x00029DE0  // sequence file offset
	; TBL_AUDIOSEQ 		    		 = 0x00B89AD0  // sequence pointer table
	; TBL_ENTRANCECUTSCENE 		     = 0x00B65C64  // entrancecutscene table
	; TBL_ENTRANCECUTSCENE_ENTRIES   = 33          // entrancecutscene count	
	; TBL_MESSAGE 					 = 0x00B808AC  // offset for message table
	; TBL_MESSAGE_ENTRIES  		     = 2116        // entrancecutscene count
	; TBL_MESSAGE_DATA			     = 0x0092D000  //offset for english text
	; TBL_RESTRICTIONFLAG   		 = 0x00B6D2B0  //offset for restricitonflag table
	; TBL_RESTRICTIONFLAG_ENTRIES    = 73	       //restrictionflag count
	; TBL_DMA                = 0x00007430  // dma table
	; TBL_DMA_ENTRIES        = 1526        // dma entries
	; TBL_OVL_GAMESTATE      = 0x00B672A0  // game state overlay table
	; TBL_OVL_PLAYER         = 0x00B743E0  // pause/player ovl table
	; TBL_OVL_MAPMARK        = 0x00B67B58  // map_mark_data ovl table
	; TITLECARD_W            = 144         // title card dimensions
	; TITLECARD_H            = 48          // use 24 for jp only
	; VRAM_CODE              = 0x800110A0  // vram start of code
	; VROM_CODE              = 0x00A87000  // vrom start of code
	; VROM_PLAYER            = 0x00BCDB70  // vrom start of player_actor
	
	; DMA_ITEM_FIELD         = 10          // icon_item_field_static
	; DMA_ITEM_LOCALIZED     = 14          // last icon_item_x_static
	; DMA_CODE               = 27
	; DMA_OVL_TITLE			 = 29
	; DMA_OVL_SELECT		 = 30
	; DMA_OVL_OPENING		 = 31
	; DMA_OVL_FILE_CHOOSE	 = 32
	; DMA_OVL_KALEIDO_SCOPE	 = 33
	; DMA_OVL_PLAYER_ACTOR	 = 34
	; DMA_OVL_MAP_MARK_DATA	 = 35
	
	; DMA_ACTOR_FIRST        = 36          // En_Test
	; DMA_ACTOR_LAST         = 497         // Shot_Sun
	; DMA_OBJECT_FIRST       = 498         // gameplay_keep
	; DMA_OBJECT_LAST        = 879         // object_zl4
	; DMA_G_PN_FIRST         = 880         // g_pn_01
	; DMA_G_PN_LAST          = 936         // g_pn_57
	; DMA_SKYBOX_FIRST       = 941         // vr_fine0_static
	; DMA_SKYBOX_LAST        = 960         // vr_holy1_pal_static
	; DMA_PRERENDER_FIRST    = 961         // vr_MDVR_static
	; DMA_PRERENDER_LAST     = 1004        // vr_FCVR_pal_static
	; DMA_SCENE_FIRST        = 1007        // ddan_scene
	; DMA_SCENE_LAST         = 1495        // ganontikasonogo_room_1
	; DMA_UNUSED_FIRST       = 1496        // bump_texture_static
	; DMA_UNUSED_LAST        = 1508        // anime_texture_6_static
	; DMA_SOFTSPRITE         = 1509        // softsprite_matrix_static
	; DMA_BLANK_FIRST        = 1510        // first blank dma entry
	; DMA_BLANK_LAST         = 1525        // last blank dma entry
	
	; ACTID_LINK             = 0           // link's actor id
	
	// hard-coded function pointers for ovl_player_actor
	; OFS_OVL_PLAYER_ACTOR_INIT_HI  = 0x00B0D5B8  // init
	; OFS_OVL_PLAYER_ACTOR_INIT_LO  = 0x00B0D5C0
	; OFS_OVL_PLAYER_ACTOR_DEST_HI  = 0x00B0D5C8  // dest
	; OFS_OVL_PLAYER_ACTOR_DEST_LO  = 0x00B0D5D4
	; OFS_OVL_PLAYER_ACTOR_MAIN_HI  = 0x00B0D5DC  // main (update)
	; OFS_OVL_PLAYER_ACTOR_MAIN_LO  = 0x00B0D5E8
	; OFS_OVL_PLAYER_ACTOR_DRAW_HI  = 0x00B0D5F0  // draw
	; OFS_OVL_PLAYER_ACTOR_DRAW_LO  = 0x00B0D5FC
	
	// hard-coded function pointers for ovl_kaleido_scope
	; OFS_OVL_KALEIDO_SCOPE_INIT_HI = 0x00B0FE48  // init
	; OFS_OVL_KALEIDO_SCOPE_INIT_LO = 0x00B0FE50
	; OFS_OVL_KALEIDO_SCOPE_DRAW_HI = 0x00B0FE58  // draw
	; OFS_OVL_KALEIDO_SCOPE_DRAW_LO = 0x00B0FE64;
}

/* valid (fmt, bpp) options for png functions */
enum n64texconv_fmt
{
	N64TEXCONV_RGBA = 0
	, N64TEXCONV_YUV
	, N64TEXCONV_CI
	, N64TEXCONV_IA
	, N64TEXCONV_I
};
enum n64texconv_bpp
{
	N64TEXCONV_4 = 0
	, N64TEXCONV_8
	, N64TEXCONV_16
	, N64TEXCONV_32
};

enum bool
{
	false = 0
	, true = 1
	, compress = 1
};

//}

/* helper function that writes lui, addiu pair into rom; hi and lo
   must be rom offsets of lui and addiu opcodes, respectively */
int
join_ptr(struct rom *rom, int hi, int lo, int correct)
{
	int v;
	int tell;

	/* back up rom address */
	tell = rom.tell();

	/* retrieve hi part of pointer */
	rom.seek(hi + 2);
	hi = rom.read16();

	/* retrieve low part of pointer */
	rom.seek(lo + 2);
	lo = rom.read16();
	
	/* value correction */
	if (correct && (u16(lo) & 0x8000))
		hi--;

	/* restore rom address */
	rom.seek(tell);
	
	return (hi << 16) | lo;
}

void
system_overlay(struct rom *rom)
{
	struct conf *conf;
	char *funcname;
	char *filename;
	char *outname;
	char *name;
	FILE *fp;
	FILE *fp2;
	int   var;
	int  *entry;
	int  *Oarr;
	int  *arr;
	int   func;
	int   vram;
	int   start;
	int   end;
	int   ptr;
	int   i;
	
	//dir_enter("overlay");
	
	/* allocate buffer */
	outname = malloc(64);
	
	/* overlay filenames */
	filename =
		"ovl_title\0"          /* n64 logo animation       */
		"ovl_select\0"         /* map select               */
		"ovl_opening\0"        /* initialized title screen */
		"ovl_file_choose\0"    /* file select screen       */
		"ovl_kaleido_scope\0"  /* pause screen             */
		"ovl_player_actor\0"   /* link's actor             */
		"ovl_map_mark_data\0"  /* minimap icon data        */
	;
	
	funcname =
		"init\0"
		"dest\0"
		"main\0"
		"draw\0"
	;
	
	/* create a list of offsets to individual overlay table entries */
	entry = int_array(
		7                                // num elements
		, TBL_OVL_GAMESTATE + 2 * 48     // ovl_title
		, TBL_OVL_GAMESTATE + 1 * 48     // ovl_select
		, TBL_OVL_GAMESTATE + 4 * 48     // ovl_opening
		, TBL_OVL_GAMESTATE + 5 * 48     // ovl_file_choose
		, TBL_OVL_PLAYER    + 0 * 28     // ovl_kaleido_scope
		, TBL_OVL_PLAYER    + 1 * 28     // ovl_player_actor
		, TBL_OVL_MAPMARK                // ovl_map_mark_data
	);
	
	/* create array of offsets to hard-coded split function pointers */
	Oarr = int_array(
	   19                               // num elements
	   
	   // these all contain none
		, 0                              // ovl_title
		, 0                              // ovl_select
		, 0                              // ovl_opening
		, 0                              // ovl_file_choose
		
		, OFS_OVL_KALEIDO_SCOPE_INIT_HI  // ovl_kaleido_scope
		, OFS_OVL_KALEIDO_SCOPE_INIT_LO
		, OFS_OVL_KALEIDO_SCOPE_DRAW_HI
		, OFS_OVL_KALEIDO_SCOPE_DRAW_LO
		, 0
		
		, OFS_OVL_PLAYER_ACTOR_INIT_HI   // ovl_player_actor
		, OFS_OVL_PLAYER_ACTOR_INIT_LO
		, OFS_OVL_PLAYER_ACTOR_DEST_HI
		, OFS_OVL_PLAYER_ACTOR_DEST_LO
		, OFS_OVL_PLAYER_ACTOR_MAIN_HI
		, OFS_OVL_PLAYER_ACTOR_MAIN_LO
		, OFS_OVL_PLAYER_ACTOR_DRAW_HI
		, OFS_OVL_PLAYER_ACTOR_DRAW_LO
		, 0
		
		, 0                              // ovl_map_mark_data
	);
	
	i = 0;
	arr = Oarr;
	while (i < 7)
	{
		/* enter overlay name directory */
		name = substring(filename, i);
		dir_enter(name);
		
		/* go to table entry (skip first word) */
		rom.seek(entry[i] + 4);

		/* open configuration file */
		fp = fopen("conf.txt", "wb");
		
		/* create out file name with extension */
		sprintf(outname, "%s.zovl", name);
		
		/* parse table entry */
		start = rom.read32();    /* vrom start */
		end   = rom.read32();    /* vrom end   */
		vram  = rom.read32();    /* vram start */
		rom.read32();            /* vram end   */
		
		/* write configuration file */
		func = 0;
		while (*arr)
		{
			/* get name */
			name = substring(funcname, func);
			
			/* hard-coded fix so ovl_kaleido_scope has "draw" */
			if (i == 4 && func == 1)
				name = "draw";
			
			/* combine split function pointer, write into config file */
			ptr = join_ptr(rom, arr[0], arr[1], true);
			fprintf(fp, "%s         0x%08X\n", name, ptr);
			
			/* advance to next function */
			arr = arr + 2;
			func++;
		}
		arr++; /* skip trailing 0 */
		
		/* game state overlays */
		if (i < 4)
		{
			rom.seek_cur(4);
			fprintf(fp, "init         0x%08X\n", rom.read32());
			fprintf(fp, "dest         0x%08X\n", rom.read32());
			rom.seek_cur(12);
			fprintf(fp, "size         0x%08X\n", rom.read32());
		}
		/* ovl_map_mark_data */
		else if (i == 6)
			fprintf(fp, "dungeon_mark_data   0x%08X\n", rom.read32());
		/* vram */
		fprintf(fp, "vram         0x%08X\n", vram);
		
		/* extract file */
		rom.extract(outname, start, end);

		/*build mapselect table*/
		if (!strcmp(name, "ovl_select"))
		{

			rom.extract("ovl_select - copy.bin", start, end);
			dir_leave();
			dir_leave();
			dir_enter("scene");

			/*open map select table and write header*/
			fp2 = fopen("mapselect.tsv","wb");
			fprintf(fp2,"index\tentrance index\n");

			/*find the table entries in the rom and write them to the table*/
			rom.seek(start + TBL_MAP_SELECT+10);
			var = 0;
			while (var < TBL_MAP_SELECT_ENTRIES)
			{
				fprintf(fp2, "%d\t%X\n", var+1,  rom.read16());
				rom.seek_cur(10);
				var++;
			}
			/*close table file*/
			fclose(fp2);
			dir_leave();
			dir_enter("system");
			dir_enter("ovl_select");
		}
		
		/* advance to next */
		dir_leave();
		fclose(fp);
		i++;
	}
	
	/* cleanup */
	free(outname);
	free(Oarr);
	//dir_leave();
}

void
systemdir(struct rom *rom)
{
	dir_enter("system");
	system_overlay(rom);
	dir_leave();
}

/*this dumps an instrument's data structure to a file. It starts at "pointer" and dumps 
until it recognizes the next data structure or the beginning of the envelopes*/
void
dumpinstrumentstructure(struct rom *rom,int pointer, int file, int index)
{
	int var;
	int test;
	int var2;

	rom.seek(pointer);
	var = 0;
	test =0;
	while (test == 0)
	{	
		/*writes one byte to the file*/
		fprintf(file, "%c", rom.read8());
		var++;

		/*now we jump forward looking for special data that will tell us where the data structure ends*/
		if (var > 24)
		{
			/*checks if the next line is an envelope looking for FFFF0000*/
			rom.seek_cur(12);
			if (rom.read16() == 0xFFFF)
			{
				if (rom.read16() == 0x0000)
				{
					if (var/16*16 == var)
					{
					test = 1;
					}
				}
				rom.seek_cur(-2);
			}

			/*checks to see if the next line is a datachunk by looking for 0000000200000002*/
			rom.seek_cur(2);
			if (rom.read32() == 2)
			{
				if (rom.read32() == 2)
				{
					test = 1;
				}
				rom.seek_cur(-4);
			}	
			/*checks to see if the next line is a datachunk by looking for 0000000000004211*/
			rom.seek_cur(-4);
			if (rom.read32() == 0)
			{
				if (rom.read32() == 0x4211)
				{
					test = 1;
				}
				rom.seek_cur(-4);
			}
			/*checks to see if the next line is a datachunk by looking for 0000000200000004*/
			rom.seek_cur(-4);
			if (rom.read32() == 2)
			{
				if (rom.read32() == 4)
				{
					test = 1;
				}
				rom.seek_cur(-4);
			}
			/*this is a fix for the master bank and actor sounds bank as they have a different structure style*/
			rom.seek_cur(-8);
			var2 = rom.read32();
			if (var2 == 0xF0 && index == 1)
				{
					test = 1;
				}
			if (var2 == 0x190 && index == 0)
				{
					test = 1;
				}
			rom.seek_cur(-16);
		}
	}
}

void
audiotable(struct rom *rom)
{	

	/*display message in console*/
	printf("dumping audiotable...\n");

	/*open directory*/
	dir_enter("audio");
	dir_enter("audiotable");
	
	/*extract tables for both text editors */
	rom.extract("audiotable.bin",TBL_AUDIOTABLE_FILE, TBL_AUDIOTABLE_FILE+ TBL_AUDIOTABLE_FILE_SIZE);
	
	/*exit the directory*/
	dir_leave();
	dir_leave();
}

void
audiobank(struct rom *rom)
{	
	FILE *configfile;
	FILE *datafile;
	int numberofbanks;
	int index;
	int instrumentindex;
	int bankpointer;
	int data;
	int instrumentnumber;
	int sampletablenumber;
	int sampleoffset;
	int drums;
	int sfx;
	int nameindex;
	int instrumentpointer;
	int name;
	int name2;
	int var;
	int var2;
	int length;
	int pitch1;
	int pitch2;
	int pitch3;
	int dataptr1;
	int dataptr2;
	int dataptr3;

	/*allocate memory for name*/
	name = malloc(256);
	name2 = malloc(256);

	/*enter audio folder*/
	dir_enter("audio");
	dir_enter("banks");
	dir_enter("_vanilla");

	/*find and read the number of audiobanks*/
	rom.seek(TBL_AUDIOBANK);
	numberofbanks = rom.read16();

	/*dump all the audiobanks until index is at the last bank*/ 
	index = 0;
	nameindex =0;
	while (index < numberofbanks - 1)
	{
		/*display progress*/
		printf("\rworking on AUDIO BANKS %d/%d:", index, numberofbanks-2);

		/*seek to table entry to read bank info*/
		rom.seek(TBL_AUDIOBANK + 16 + index*16);
		bankpointer = rom.read32();
		length = rom.read32();
		rom.seek_cur(2);
		sampletablenumber = rom.read8();
		rom.seek_cur(1);		
		instrumentnumber = rom.read8();
		drums = rom.read8();

		/*sets sample offset for the bank, used later when writing sample pointers.*/
		rom.seek(TBL_AUDIOSAMPLE + sampletablenumber*16);
		sampleoffset = rom.read32();

		/*open the bank folder*/
		sscanf(tsv_col_row(g_tsv,"audiobank",index + 1), "%s", name2);
		sprintf(name,"%d-%s-%X",index,name2,index);
		dir_enter(name);

		rom.extract(name, TBL_AUDIOBANK_FILE + bankpointer, TBL_AUDIOBANK_FILE + bankpointer + length);

		/*checks if there's drums and sfx*/
		rom.seek(TBL_AUDIOBANK_FILE + bankpointer);
		drums = rom.read32();
		sfx = rom.read32();
		if (drums>0 && index !=1)
		{
			/*enter the drums folder and open the drums file*/
			dir_enter("_drums");
			datafile = fopen("drums", "wb");

			/*seeks to drum-index pointer list and reads first drum index*/
			rom.seek(TBL_AUDIOBANK_FILE + bankpointer + drums);
			var = rom.read32();
			
			/* writes all the drum indexes*/
			rom.seek(TBL_AUDIOBANK_FILE + bankpointer + var);
			while (var < drums) 
			{
			fprintf(datafile, "%c", rom.read8());
			var++;
			}

			/*steps back to read the envelope pointer*/
			rom.seek_cur(-4);
			var = rom.read32();

			/*open the config file and write the header*/
			configfile = fopen("config.tsv","wb");
			fprintf(configfile, "atkrate\tatklvl\tdcy1rt\tdcy1lvl\tdcy2rt\tdcy2lvl\n");



			/*go to the envelope and add info to file*/
			rom.seek(TBL_AUDIOBANK_FILE + bankpointer + var);
			fprintf(configfile, "%d", rom.read16());//attackrate
			fprintf(configfile, "\t%d", rom.read16());//attacklevel
			fprintf(configfile, "\t%d", rom.read16());//decay1rate
			fprintf(configfile, "\t%d", rom.read16());//decay1level
			fprintf(configfile, "\t%d", rom.read16());//decay2rate
			fprintf(configfile, "\t%d\n", rom.read16());//decay2level

			
			/*goes to envelope and writes that below the drum indexes*/
			rom.seek(TBL_AUDIOBANK_FILE + bankpointer + var);
			var = 0;
			while(var<16)
			{
				fprintf(datafile, "%c", rom.read8());
				var++;
			}

			/*sets var to 1st drum index pointer*/
			rom.seek(TBL_AUDIOBANK_FILE + bankpointer + drums);
			var = rom.read32();
			
			/*write the second teir column names for the config file*/
			fprintf(configfile, "length\tsample\t\t\t\t\n");

			/*finds all the unique drum data structures*/
			instrumentindex = 0;
			while (var < drums) 
			{
				/*goes to the drum index and finds the data-structure offset*/
				rom.seek(TBL_AUDIOBANK_FILE + bankpointer + var);
				rom.seek_cur(4);
				var2 = rom.read32();

				/*checks if it's a unique structure*/
				if (instrumentindex < var2)
				{
					/*go to data and copy it to drum file*/
					instrumentindex = var2;
					dumpinstrumentstructure(rom,TBL_AUDIOBANK_FILE + bankpointer + var2, datafile, index);

					/*seek to the data pointer and write the sample's length, address, and pitch to the file*/
					rom.seek(TBL_AUDIOBANK_FILE + bankpointer + var2);
					rom.seek_cur(2);
					fprintf(configfile, "%X\t%X\t\t\t\t\n", rom.read16(),rom.read32()+sampleoffset);
				}
				var = var + 16;
			}
			/*close drum file and leave drum folder*/
			fclose(configfile);
			fclose(datafile);
			dir_leave();
		}


		/*check if there are sound effects*/
		if (sfx > 0)
		{
			/*enters sfx folder*/
			dir_enter("_sfx");

			/*writes all the sound effets to file by reading till the end of the soundbank*/
			var = 0;
			while (sfx + var*8 < length)
			{
				/*go to the index and get the pointer to the data-sructure*/
				rom.seek(TBL_AUDIOBANK_FILE + bankpointer + sfx + var*8);
				var2 = rom.read32();
				/*check if it's a valid pointer before creating a file*/
				if (var2 > 0 && var2 < length)
				{
					
					/*create file and with indexed name*/
					sprintf(name, "soundeffect-%d", var);
					datafile = fopen(name,"wb");

					/*write the index to the header of the file in a 16 byte format, the last 8 bytes are zeroed just to make it more readable*/
					rom.seek_cur(-4);
					fprintf(datafile, "%c%c%c%c", rom.read8(),rom.read8(),rom.read8(),rom.read8());
					fprintf(datafile, "%c%c%c%c", rom.read8(),rom.read8(),rom.read8(),rom.read8());
					fprintf(datafile, "%c%c%c%c", 9,9,9,9);
					fprintf(datafile, "%c%c%c%c", 9,9,9,9);

					/*dump the sound effect structure to the file and close the file*/
					dumpinstrumentstructure(rom,TBL_AUDIOBANK_FILE + bankpointer + var2, datafile, index);
					fclose(datafile);
				}
				/*advance one sound effect index*/
				var++;
			}
			/*leave the sound effect folder*/
			dir_leave();
		}

		/*read each instrument and create files and config table*/
		instrumentindex = 0;
		while (instrumentindex < instrumentnumber)
		{
			/*find the location of instruments description in the bank*/			
			rom.seek(TBL_AUDIOBANK_FILE + bankpointer + 8 + instrumentindex*4);
			instrumentpointer = rom.read32();

			/*if instrument isn't blank*/
			if (instrumentpointer > 0)		
			{
				/*sets the name of the instrument and enters the folder*/
				if (index > 2)
				{
					nameindex++;
					if  (TBL_AUDIOBANK_FILE != 0x00019030 && nameindex == 57)
					{
						nameindex++; //skips the extra unknown instrument in debug for naming folders.
					}
					sscanf(tsv_col_row(g_tsv,"instrument",nameindex), "%s", name2);
				}
				sprintf(name,"%d - %s",instrumentindex,name2);
				dir_enter(name);

				/*open the config file and write the header*/
				configfile = fopen("config.tsv","wb");
				fprintf(configfile, "split1\tsplit2\tsplit3\trelease\tatkrate\tatklvl\tdcy1rt\tdcy1lvl\tdcy2rt\tdcy2lvl\n");

				/*go to the instrument description and read it*/
				rom.seek(TBL_AUDIOBANK_FILE + bankpointer + instrumentpointer);

				/*write the instrument entry to the config table*/
				fprintf(configfile, "%d", rom.read8());//split1
				fprintf(configfile, "\t%d", rom.read8());//split2
				fprintf(configfile, "\t%d", rom.read8());//split3
				fprintf(configfile, "\t%d", rom.read8());//release

				/*get the envelope pointer and set the envelope bankpointer position*/
				var = rom.read32();

				/*get the data pointer and pitches for later*/
				dataptr1 = rom.read32();
				pitch1= rom.read32();
				dataptr2 = rom.read32();
				pitch2 = rom.read32();
				dataptr3 = rom.read32();
				pitch3 = rom.read32();

				/*go to the envelope and add info to file*/
				rom.seek(TBL_AUDIOBANK_FILE + bankpointer + var);
				fprintf(configfile, "\t%d", rom.read16());//attackrate
				fprintf(configfile, "\t%d", rom.read16());//attacklevel
				fprintf(configfile, "\t%d", rom.read16());//decay1rate
				fprintf(configfile, "\t%d", rom.read16());//decay1level
				fprintf(configfile, "\t%d", rom.read16());//decay2rate
				fprintf(configfile, "\t%d\n", rom.read16());//decay2level

				/*write the second teir column names for the config file*/
				fprintf(configfile, "length1\tsample1\tpitch1  \tlength2\tsample2\tpitch2  \tlength3\tsample3\tpitch3  \n");
				
				/*check if data exists before creating the data file*/
				if (dataptr1)
				{
					/*open the data file and dump instrument structure inside before closing the file*/
					datafile = fopen("data_1", "wb");
					dumpinstrumentstructure(rom,TBL_AUDIOBANK_FILE + bankpointer + dataptr1, datafile, index);
					fclose(datafile);

					/*seek to the data pointer and write the sample's length, address, and pitch to the file*/
					rom.seek(TBL_AUDIOBANK_FILE + bankpointer + dataptr1);
					rom.seek_cur(2);
					fprintf(configfile, "%X\t%X\t%X\t", rom.read16(),rom.read32()+sampleoffset,pitch1);
				}
				else
				{	
					/*if there's no data file write in zeroes into the config file*/
					fprintf(configfile, "0000\t0000\t00000000\t");
				}
				/*check if data exists before creating the data file*/
				if (dataptr2)
				{
					/*open the data file and dump instrument structure inside before closing the file*/
					datafile = fopen("data_2", "wb");
					dumpinstrumentstructure(rom,TBL_AUDIOBANK_FILE + bankpointer + dataptr2, datafile,index);
					fclose(datafile);
					
					/*seek to the data pointer and write the sample's length, address, and pitch to the file*/
					rom.seek(TBL_AUDIOBANK_FILE + bankpointer + dataptr2);
					rom.seek_cur(2);
					fprintf(configfile, "%X\t%X\t%X\t", rom.read16(),rom.read32()+sampleoffset,pitch2);
				}
				else
				{	
					/*if there's no data file write in zeroes into the config file*/
					fprintf(configfile, "0000\t0000\t00000000\t");
				}

				/*check if data exists before creating the data file*/
				if (dataptr3)
				{
					/*open the data file and dump instrument structure inside before closing the file*/
					datafile = fopen("data_3", "wb");
					dumpinstrumentstructure(rom,TBL_AUDIOBANK_FILE + bankpointer + dataptr3, datafile,index);
					fclose(datafile);
					
					/*seek to the data pointer and write the sample's length, address, and pitch to the file*/
					rom.seek(TBL_AUDIOBANK_FILE + bankpointer + dataptr3);
					rom.seek_cur(2);
					fprintf(configfile, "%X\t%X\t%X\t", rom.read16(),rom.read32()+sampleoffset,pitch3);
				}
				else
				{	
					/*if there's no data file write in zeroes into the config file*/
					fprintf(configfile, "0000\t0000\t00000000\t");
				}

				/*close the instrument config file and leave the folder*/
				fclose(configfile);
				dir_leave();
			}

			/*count up the instruments*/
			instrumentindex++;
		}

		/*leave the audiobank folder and advance to next bank*/
		dir_leave();
		index++;
	}

	/*extract final bank for building. I'm not sure what this data-does but it should be placed at the end of the data-banks before empty space*/
	rom.seek(TBL_AUDIOBANK + 16 + index*16);
	bankpointer = rom.read32();
	length = rom.read32();
	rom.extract(".do_not_delete", TBL_AUDIOBANK_FILE + bankpointer, TBL_AUDIOBANK_FILE + bankpointer + length);

	/*leave the audio and audiobank and vanilla folders*/
	dir_leave();
	dir_leave();
	dir_leave();

	/*keep console update on a new line*/
	printf("\n");
}


void
audioseq(struct rom *rom)
{	
	FILE *fp;
	int numberofsequences;
	int index;
	int start;
	int sequenceinstrumentpointer;
	int var;
	int length;
	int type;
	int name;
	int name2;

	/*message console*/
	printf("working on AUDIO SEQUENCES...\n");

	/*allocate memory for name*/
	name = malloc(256);
	name2 = malloc(256);

	/*enter audio folder*/
	dir_enter("audio");

	/*seek to sequence table header and read sequence number*/
	rom.seek(TBL_AUDIOSEQ);
	numberofsequences = rom.read16();

	/*open table for editing*/
	fp = fopen("sequencetable.tsv","wb");

	/*print header*/
	fprintf(fp, "%s", "index\tstart\tlength\ttype\tbank\tsequencename\tnameofbank");
	fprintf(fp, "\n");

	/*read the whole table using numberofsequences*/
	index = 0;
	while (index < numberofsequences)
	{
		/*seek to table entry to read sequence info*/
		rom.seek(TBL_AUDIOSEQ+ 16 + index*16);
		start = rom.read32();
		length = rom.read32();
		rom.seek_cur(1);
		type = rom.read8();



		/*write to table*/
		fprintf(fp, "0x%04X", index);
		fprintf(fp, "\t%X", start);
		fprintf(fp, "\t%X", length);
		fprintf(fp, "\t%X", type);


		/*read and write what bank each sequence uses(i did away with multiple banks per sequence)*/
		rom.seek(TBL_SEQUENCEINSTRUMENTSET + index*2);
		sequenceinstrumentpointer =  rom.read16();
		rom.seek(TBL_SEQUENCEINSTRUMENTSET + sequenceinstrumentpointer + 1);
		var = rom.read8();
		fprintf(fp, "\t%X", var);
		sscanf(tsv_col_row(g_tsv,"sequence",index+1), "%s", name2);
		sprintf(name,"%d-%s-%X",index,name2,index);
		fprintf(fp, "\t%s", name);
		sscanf(tsv_col_row(g_tsv,"audiobank",var+1), "%s", name2);
		sprintf(name,"%d-%s-%X",var,name2,var);
		fprintf(fp, "\t%s", name);



		fprintf(fp, "\n");

		/*enter sequences folder to write sequence data and then leave*/
		dir_enter("sequences");
		dir_enter("_vanilla");

		sscanf(tsv_col_row(g_tsv,"sequence",index + 1), "%s", name2);
		sprintf(name,"%d - %s - %X.bin",index,name2,index);
		rom.extract(name, TBL_SEQUENCE_FILE + start, TBL_SEQUENCE_FILE + start+length);
		dir_leave();
		dir_leave();
		/*advance forward in table*/
		index ++;
	}
	/*close table and leave folder*/
	fclose(fp);
	dir_leave();
}

void
route(struct rom *rom)
{
	FILE *fp;
	char *music;
	char *card;
	int fadeout;
	int fadein;
	int index;
	int scene;
	int spawn;
	int var;

		/*message console*/
	printf("building ROUTING TABLE...\n");

	/*enter folder*/
	dir_enter("scene");
		
	/* open route.txt for writing */
	fp = fopen("route.tsv", "wb");
		
	/* print table header */
	fprintf(fp, "%s", "index\tscene\tspawn\tmusic\ttitle\tfadein\tfadeout");
	fprintf(fp, "\n");
	
	/*populate table*/
	index = 0;
	while (index < TBL_ROUTE_ENTRIES)
	{
		/* go to table entry */
		rom.seek(TBL_ROUTE + index * 4);
		
		/* parse table entry */
		scene = rom.read8();
		spawn = rom.read8();
		var   = rom.read16();
		
		/* unpack var */
		music   = (var & 0x8000) ? "go" : "stop";
		card    = (var & 0x4000) ? "on" : "off" ;
		fadein  = (var & 0x3F80) >> 7;
		fadeout = (var & 0x007F);
		
		/* print table entry */
		fprintf(fp, "0x%04X", index);
		fprintf(fp, "\t%X", scene);
		fprintf(fp, "\t%d", spawn);
		fprintf(fp, "\t%s", music);
		fprintf(fp, "\t%s", card);
		fprintf(fp, "\t%d", fadein);
		fprintf(fp, "\t%d", fadeout);
		fprintf(fp, "\n");
		
		/* advance to next entry */
		index++;
	}
	
	/*close file and leave folder*/
	fclose(fp);
	dir_leave();
}

void
entrancecutscene(struct rom *rom)
{
	FILE *fp;
	int index;
	int entrance;
	int age;
	int *agestr;
	int flag;
	int offset;
	int sep;

	/*message console*/
	printf("building ENTRANCE CUTSCENE TABLE...\n");

	/*enter scene folder*/
	dir_enter("scene");

	/*set up age array*/
	agestr = int_array(3, "child", "adult", "both");
	
	/* separator whitespace */
	sep = 16;
	
	/* open entrancecutscene.txt for writing */
	fp = fopen("entrancecutscene.tsv", "wb");
		
	/* print table header */
	fprintf(fp,  "%s", "index\tentry\tage\tflag\toffset");
	fprintf(fp, "\n");
	
	/* populate table */
	index = 0;
	while (index < TBL_ENTRANCECUTSCENE_ENTRIES)
	{
		/* go to table entry */
		rom.seek(TBL_ENTRANCECUTSCENE + index * 8);
		
		/* parse table entry */
		entrance = rom.read16();
		age = rom.read8();
		flag = rom.read8();
		offset   = rom.read32();

		
		/* print table entry */
		fprintf(fp, "0x%04X", index);
		fprintf(fp, "\t%X", entrance);
		fprintf(fp, "\t%s", agestr[age]);		
		fprintf(fp, "\t%X", flag);
		fprintf(fp, "\t%X", offset);
		fprintf(fp, "\n");
		
		/* advance to next entry */
		index++;
	}
	
	/*close file and exit folder*/
	fclose(fp);
	dir_leave();
}



void
restrictionflag(struct rom *rom)
{
	FILE *fp;
	int index;
	int variable;
	int sceneid;
	int xx;
	int yy;
	int zz;

	/*message the console*/
	printf("building RESTRICTIONFLAG TABLE...\n");
	
	/* open directory and open entrancecutscene.txt for writing */
	dir_enter("scene");
	fp = fopen("restrictionflag.tsv", "wb");
		
	/* print table header */
	fprintf(fp, "%s","index");
	fprintf(fp, "%s", "\tscene\tbottle\tabutton\tbbutton\thealth\twarpson\tocarina\thooksht\ttradeit\tglobal\tdinnayr\tfarore\tsunsong");
	fprintf(fp, "\n");
	
	/*populate table*/
	index = 0;
	while (index < TBL_RESTRICTIONFLAG_ENTRIES)
	{
		/* go to table entry */
		rom.seek(TBL_RESTRICTIONFLAG + index * 4);
		
		/* parse table entry */
		sceneid = rom.read8();
		xx = rom.read8();
		yy = rom.read8();
		zz   = rom.read8();

		/* print table entry (uses bit-test for flags)*/
		fprintf(fp, "0x%04X", index);
		fprintf(fp, "\t%X", sceneid);
		fprintf(fp, "\t%s", (xx & (1 << 0)) ? "on" : "off");
		fprintf(fp, "\t%s", (xx & (1 << 2)) ? "on" : "off");
		fprintf(fp, "\t%s", (xx & (1 << 4)) ? "on" : "off");
		fprintf(fp, "\t%s", (xx & (1 << 6)) ? "on" : "off");
		fprintf(fp, "\t%s", (yy & (1 << 0)) ? "on" : "off");
		fprintf(fp, "\t%s", (yy & (1 << 2)) ? "on" : "off");
		fprintf(fp, "\t%s", (yy & (1 << 4)) ? "on" : "off");
		fprintf(fp, "\t%s", (yy & (1 << 6)) ? "on" : "off");	
		fprintf(fp, "\t%s", (zz & (1 << 0)) ? "on" : "off");
		fprintf(fp, "\t%s", (zz & (1 << 2)) ? "on" : "off");
		fprintf(fp, "\t%s", (zz & (1 << 4)) ? "on" : "off");
		fprintf(fp, "\t%s", (zz & (1 << 6)) ? "on" : "off");		
		fprintf(fp, "\n");
		
		/* advance to next entry */
		index++;
	}
	/*close file and leave directory */
	fclose(fp);
	dir_leave();
}

void
message(struct rom *rom)
{ 
	FILE *fp;
	int message_data_end;
	int index;
	
	/*display message in console*/
	printf("dumping messages...\n");

	/*open directory*/
	dir_enter("messages");
	
	/*extract tables for both text editors */
	rom.extract("table.bin",TBL_MESSAGE, TBL_MESSAGE + TBL_MESSAGE_ENTRIES*8);
	rom.extract("MessageTable.tbl",TBL_MESSAGE, TBL_MESSAGE + TBL_MESSAGE_ENTRIES*8);
	
	/*find the length of the english data*/
	rom.seek(TBL_MESSAGE + TBL_MESSAGE_ENTRIES*8 - 3);
	message_data_end   = rom.read24();

	/*extract the data*/
	rom.extract("0_message_data_static.bin",TBL_MESSAGE_DATA, TBL_MESSAGE_DATA + message_data_end);
    rom.extract("StringData.bin",TBL_MESSAGE_DATA, TBL_MESSAGE_DATA + message_data_end);

	/*exit the directory*/
	dir_leave();
}


void
scene(struct rom *rom)
{
	FILE *fp;
	char *b;
	char *b_end;
	char *room_name;
	void *title_buf;
	char room_count;
	int index;
	int start;
	int end;
	int scard;
	int ecard;
	int rinit;
	int unk_a;
	int unk_b;
	int sz;
	
	/* allocate room name */
	room_name = malloc(16);
	
	/* allocate reusable title card memory */
	title_buf = malloc(TITLECARD_W * TITLECARD_H * 4);
	
	/* enter and parse folder */
	dir_enter("scene");
	dir_enter("_vanilla");
	
	/* repeats for every item in the list */
	index = 0;
	while (index < TBL_SCENE_ENTRIES)
	{
		/* display progress */
		printf("\r""scene %d/%d: ", index, TBL_SCENE_ENTRIES - 1);
		
		/* create and enter directory */
		dir_enter(
			dir_mkname(
				index
				, tsv_col_row(g_tsv, "scene", index + 1)
			)
		);
		
		/* go to table entry */
		rom.seek(TBL_SCENE + index * 20);
		
		/* parse table entry */
		start = rom.read32();  /* vrom start          */
		end   = rom.read32();  /* vrom end            */
		scard = rom.read32();  /* title card start    */
		ecard = rom.read32();  /* title card end      */
		unk_a = rom.read8();   /* unknown             */
		rinit = rom.read8();   /* render init func id */
		unk_b = rom.read8();   /* unknown             */
		
		/* used entries have non-zero start */
		if (start)
		{
			/* extract file */
			rom.extract("scene.zscene", start, end);
			sz = end - start;
			
			/* grab raw scene data */
			b = rom.raw(start);
			b_end = b + sz;
			
			/* search scene header for room command (0x04) */
			while (b < b_end && *b != 0x04)
			{
				/* end loop conditions */
				if (
					*b == 0x14          /* end command     */
					|| u8(*b) >= 0x20   /* invalid command */
				)
					b = b_end;
				
				/* advance to next header command */
				b = b + 8;
			}
			
			/* failed to locate room command, or it is invalid */
			if (
				b >= b_end                   /* no room command found */
				|| b[1] <= 0                 /* invalid room count    */
				|| get16(b+2)                /* bytes 2, 3 aren't 0   */
				|| b[4] != 0x02              /* invalid ram segment   */
				|| (b[7] & 3)                /* unaligned pointer     */
				|| get24(b+5) + b[1]*8 > sz  /* pointer exceeds file  */
			)
				die("invalid scene (%08X - %08X)", start, end);
			
			/* grab room list pointed to by 0x04 command */
			room_count = b[1];
			b = rom.raw(start + get24(b+5)) + room_count * 8;
			
			/* extract each room */
			while (room_count)
			{
				/* decrement */
				room_count--;
				b = b - 8;
				
				/* extract file */
				sprintf(room_name, "room_%d.zmap", room_count);
				rom.extract(room_name, get32(b), get32(b+4));
			}
		}
		
		/* if title card is used, its start will be non-zero */
		if (scard)
		{
			/* extract title.png */
			rom.extract_png(
				"title.png"
				, title_buf
				, scard
				, 0
				, TITLECARD_W
				, TITLECARD_H
				, N64TEXCONV_IA
				, N64TEXCONV_8
			);
		}
		
		/* write table settings to conf.txt */
		fp = fopen("conf.txt", "wb");
		fprintf(fp, "unk-a: %d\n", unk_a);
		fprintf(fp, "unk-b: %d\n", unk_b);
		fprintf(fp, "shader: %d\n", rinit);
		fclose(fp);
		
		/* leave directory */
		dir_leave();

		
		/* advance to next entry */
		index++;
	}
	
	/* cleanup */
	dir_leave();
	dir_leave();
	free(room_name);
	free(title_buf);
	printf("success!\n");
}

void
particle(struct rom *rom)
{
	FILE *fp;
	int index;
	int start;
	int end;
	int vram;
	int ivar;
	int unk;
	
	/* enter and parse folder */
	dir_enter("particle");
	
	/* repeats for every item in the list */
	index = 0;
	while (index < TBL_PARTICLE_ENTRIES)
	{
		/* display progress */
		printf("\r""particle %d/%d: ", index, TBL_PARTICLE_ENTRIES - 1);
		
		/* create and enter directory */
		dir_enter(
			dir_mkname(
				index
				, tsv_col_row(g_tsv, "particle", index + 1)
			)
		);
		
		/* go to table entry */
		rom.seek(TBL_PARTICLE + index * 28);
		
		/* parse table entry */
		start = rom.read32();  /* vrom start  */
		end   = rom.read32();  /* vrom end    */
		vram  = rom.read32();  /* vram start  */
		rom.read32();          /* vram end    */
		rom.read32();          /* ram address */
		ivar = rom.read32();   /* init vars   */
		unk = rom.read32();    /* unknown     */
		
		/* used entries have non-zero start */
		if (start)
		{
			/* go to rom offset of this particle overlay's init vars */
			rom.seek(start + (ivar - vram));
			
			/* handle "tuna" */
			/* NOTE: this is used for easy auto-detection in the build *
			 *       script; if you have a different preferred method  *
			 *       of managing the initialization variables, you're  *
			 *       free to change the scripts to use your own logic  */
			rom.write("tuna", 4);
			
			/* extract file */
			rom.extract("actor.zovl", start, end);
		}
		
		/* write vram and unk to conf.txt */
		fp = fopen("conf.txt", "wb");
		fprintf(fp, "vram         0x%08X\n", vram);
		fprintf(fp, "unknown      0x%08X\n", unk);
		fclose(fp);
		
		/* leave directory */
		dir_leave();
		
		/* advance to next entry */
		index++;
	}
	
	/* cleanup */
	dir_leave();
	printf("success!\n");
}

void
actor(struct rom *rom)
{
	FILE *fp;
	char *name;
	int index;
	int start;
	int end;
	int vram;
	int ivar;
	int atype;
	int naddr;
	
	/* enter and parse folder */
	dir_enter("actor");
	dir_enter("_vanilla");

	/* repeats for every item in the list */
	index = 0;
	while (index < TBL_ACTOR_ENTRIES)
	{
		/* display progress */
		printf("\r""actor %d/%d: ", index, TBL_ACTOR_ENTRIES - 1);
		
		/* go to table entry */
		rom.seek(TBL_ACTOR + index * 32);
		
		/* parse table entry */
		start = rom.read32();  /* vrom start  */
		end   = rom.read32();  /* vrom end    */
		vram  = rom.read32();  /* vram start  */
		rom.read32();          /* vram end    */
		rom.read32();          /* ram address */
		ivar  = rom.read32();  /* init vars   */
		naddr = rom.read32();  /* name addr   */
		atype = rom.read16();  /* alloc type  */
		
		/* get name string */
		/* NOTE: an assumption is being made that naddr falls inside   *
		 *       code's vram; this is fine for roms that have not been *
		 *       drastically altered, and naddr is always 0 on retail  *
		 *       roms anyway; just be aware of this if you have issues */
		if (g_tsv)
			name = tsv_col_row(g_tsv, "actor", index + 1);
		else if (naddr)
			name = rom.raw((naddr - VRAM_CODE) + VROM_CODE);
		else
			name = 0;
		
		/* create and enter directory */
		dir_enter(dir_mkname(index, name));
		
		/* used entries have non-zero start */
		if (start)
		{
			/* go to rom offset of this actor overlay's init vars */
			rom.seek(start + (ivar - vram));
			
			/* handle 0xDEAD 0xBEEF */
			/* NOTE: this is no longer used, in favor of pulling the   *
			 *       initialization variable address from the ivar     *
			 *       field in conf.txt; uncomment if you need it       */
			//rom.write16(0xDEAD);  /* 0x0000: table index    */
			//rom.seek_cur(8);      /* 0x0002: advance to 0xA */
			//rom.write16(0xBEEF);  /* 0x000A: padding        */
			
			/* extract file */
			rom.extract("actor.zovl", start, end);
		}
		
		/* write vram and atype to conf.txt */
		fp = fopen("conf.txt", "wb");
		fprintf(fp, "allocation   0x%04X\n", atype);
		fprintf(fp, "vram         0x%08X\n", vram);
		/* ivar override for actors that don't reference files */
		//if (!start && ivar) /* uncomment this if you want DEAD BEEF */
			fprintf(fp, "ivar         0x%08X\n", ivar);
		fclose(fp);
		
		/* leave directory */
		dir_leave();
		
		/* advance to next entry */
		index++;
	}
	
	/* cleanup */
	dir_leave();
	dir_leave();
	printf("success!\n");
}

void
object(struct rom *rom)
{
	int index;
	int start;
	int end;
	
	/* enter and parse folder */
	dir_enter("object");
	dir_enter("_vanilla");
	
	/* repeats for every item in the list */
	index = 0;
	while (index < TBL_OBJECT_ENTRIES)
	{
		/* display progress */
		printf("\r""object %d/%d: ", index, TBL_OBJECT_ENTRIES - 1);
		
		/* create and enter directory */
		dir_enter(
			dir_mkname(
				index
				, tsv_col_row(g_tsv, "object", index + 1)
			)
		);
		
		/* go to table entry */
		rom.seek(TBL_OBJECT + index * 8);
		
		/* parse table entry */
		start = rom.read32();
		end   = rom.read32();
		
		/* extract file */
		rom.extract("zobj.zobj", start, end);
		
		/* leave directory */
		dir_leave();
		
		/* advance to next entry */
		index++;
	}
	
	/* cleanup */
	dir_leave();
	dir_leave();
	printf("success!\n");
}

int
main(int argc, char **argv)
{
	struct rom *rom;
	struct conf *config;
	char *name;
	FILE *fp;

	/*if config doesn't exist it'll create on for ya*/
	if (!file_exists("config.tsv"))
	{
		printf("created new config file for project\n");
		fp = fopen("config.tsv", "wb");
		fprintf(fp, "configuration_name\tsetting\tconfiguration_note\n");
		fprintf(fp, "using_oot_debug_rom\ttrue\t(true = debug, false = 1.0)\n");
		fprintf(fp, "use_hex_naming_style\tfalse\t(true = index in hex when dumping)\n");
		fprintf(fp, "using_zelda's_letter\ttrue\t(true = zelda's letter, false = ocarina text editor)\n");
		fprintf(fp, "use_map_select_hack\ttrue\t(english map_select using mapselect.tsv and scene names)\n");
		fprintf(fp, "build/dump audiobank\ttrue\t(optional if you don't plan on doing audiobank stuff)\n");
		fprintf(fp, "build/dump audioseq\ttrue\t(optional if you don't plan on doing sequence stuff)\n");
		fprintf(fp, "build/dump messages\ttrue\t(if you aren't using custom dialogue you can switch this)\n");
		fclose(fp);
	}

	/*load the config file*/
	config = loadfile("config.tsv",0,0);

	/* name of rom */
	/* NOTE: the rom of the given name must exist *
	 *       in the same directory as this .rtl   */
	
	//printf("\n%s\n", );
	if (!strcmp(tsv_col_row(config, "setting", 1), "true"))
	{
		debugvariables();
		name = "oot-debug.z64";
	}
	else
	{
		ocarinaoftimevariables();
		name = "oot-1.0.z64";
	}
	
	/* initialize name lists */
	g_tsv = loadfile("oot_names.tsv", 0, true/*file is optional*/);
	
	/* folder naming style */
	if (!strcmp(tsv_col_row(config, "setting", 2), "true"))
	{
		dir_use_style("preX");
	}
	else
	{
		dir_use_style("pre");
	}
	
	/* load rom */
	rom = rom.new(name);
	
	/* dma table (dmadata) offset and number of entries */
	rom.dma(TBL_DMA, TBL_DMA_ENTRIES);
	
	/* dump rom */
	systemdir(rom);
	object(rom);
	actor(rom);
	particle(rom);
	scene(rom);
	if (!strcmp(tsv_col_row(config, "setting", 5), "true"))
	{
		audiobank(rom);
	}
	if (!strcmp(tsv_col_row(config, "setting", 6), "true"))
	{
		audioseq(rom);
	}
	
	audiotable(rom);
	
	route(rom);
	entrancecutscene(rom);
	if (!strcmp(tsv_col_row(config, "setting", 7), "true"))
	{
		message(rom);
	}
	restrictionflag(rom);



	
	/* create .zzrpl */
	name = rom.filename();
	fp = fopen("project.zzrpl", "wb");
	fprintf(fp, "zzrtl                   v0.01\n");
	fprintf(fp, "baserom                 \"%s\"\n", name);
	/* zzplayas support */
	fprintf(fp, "ZZPLAYAS_VROM_CODE      \"'%s'+0x%08X\"\n", name, VROM_CODE);
	fprintf(fp, "ZZPLAYAS_VROM_PLAYER    \"'system/overlay/ovl_player_actor/ovl_player_actor.zovl'\"\n");
	fclose(fp);
	
	/* cleanup */
	rom.free();
	return 0;
}
